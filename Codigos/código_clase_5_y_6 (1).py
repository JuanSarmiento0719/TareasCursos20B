# -*- coding: utf-8 -*-
"""Código: Clase 5 y 6.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/13iGhVVMXvR4F7qIieFzt07KhJH1G-15b

# **Taller Clase 5 y 6**

---


Estudiante: Juan Diego Sarmiento Villarreal.
Código: 2240676

## Bibliotecas
"""

import numpy as np
import scipy.integrate as integrate
import sympy as sp
import matplotlib.pyplot as plt

"""## **Sección 2.3.6.: Ejercicio 5 (b)**

---


"""

# Sección 2.3.6.: Ejercicio 5 (b)
# Definir matrices
sigma_0 = sp.Matrix([[1, 0], [0, 1]])
sigma_1 = sp.Matrix([[0, 1], [1, 0]])
sigma_2 = sp.Matrix([[0, -sp.I], [sp.I, 0]])
sigma_3 = sp.Matrix([[1, 0], [0, -1]])

# Definir el producto interno
def inner_product(a, b):
    return (a.H * b).trace()

# Lista de matrices
paulis = [sigma_0, sigma_1, sigma_2, sigma_3]
n = len(paulis)

# Construir la matriz de Gram
Gram = sp.Matrix([[inner_product(paulis[i], paulis[j]) for j in range(n)] for i in range(n)])

print("Matriz de Gram:")
sp.pprint(Gram)

# Verificar si es diagonal
es_d = Gram.is_diagonal()
print("¿Es diagonal?:", es_d)

"""## **Sección 2.3.6.: Ejercicio 6**"""

# Variable simbólica
x = sp.Symbol('x')

# Definimos el producto interno <f|g>
def prod_interno(f, g):
    return sp.integrate(f*g*sp.sqrt(1-x**2), (x, -1, 1))

# Definimos base inicial de polinomios {1, x, x^2, ..., x^n}
n = 4   # hasta grado 4
base_inicial = [x**k for k in range(n+1)]

# Gram-Schmidt
base_ortogonal = []
for i, f in enumerate(base_inicial):
    # Resta proyecciones sobre los ya ortogonales
    for g in base_ortogonal:
        f -= prod_interno(f, g)/prod_interno(g, g) * g
    base_ortogonal.append(sp.simplify(f))

print("Base ortogonal:")
for b in base_ortogonal:
    print(sp.simplify(b))

"""## **Sección 2.4.5.: Ejercicio 3**

3. (a)
"""

# Variable simbólica
x = sp.Symbol('x')

# Definimos el producto interno <f|g>
def prod_interno(f, g):
    return sp.integrate(f*g, (x, -1, 1))

# Base de monomios {1, x, x^2, x^3, x^4}
base = [1, x, x**2, x**3, x**4]

# Verificamos productos internos entre monomios distintos
print("Productos internos entre monomios distintos:\n")
for i in range(len(base)):
    for j in range(i+1, len(base)):
        val = prod_interno(base[i], base[j])
        print(f"<x^{i} | x^{j}> = {val}")

"""3. (b)"""

# símbolo
x = sp.Symbol('x')

# producto interno usual <f,g> = ∫_{-1}^{1} f g
def inner(f, g):
    return sp.simplify(sp.integrate(f*g, (x, -1, 1)))

def legendre_by_gram(n_max):
    # base inicial
    base = [x**k for k in range(n_max+1)]
    ortho = []
    for f in base:
        f = sp.simplify(f)
        for g in ortho:
            proj = inner(f, g) / inner(g, g) * g
            f = sp.simplify(f - proj)
        ortho.append(sp.simplify(f))

    # escalar para que P_n(1) = 1 (convención estándar)
    P = []
    for f in ortho:
        val1 = sp.simplify(f.subs(x, 1))
        if val1 == 0:
            # caso improbable: dividir por coeficiente líder si falla
            lc = sp.Poly(f, x).LC()
            f_scaled = sp.simplify(f / lc)
        else:
            f_scaled = sp.simplify(f / val1)
        P.append(sp.simplify(sp.expand(f_scaled)))
    return P

P = legendre_by_gram(9)  # P_0 ... P_9
for i, p in enumerate(P):
    print(f"P_{i}(x) = {sp.simplify(p)}")

"""3. (c)"""

x = sp.Symbol('x')
weight = sp.sqrt(1 - x**2)

# generar U_n por recurrencia (segunda especie)
def chebyshev_second(n_max):
    U = [sp.simplify(1), sp.simplify(2*x)]
    if n_max == 0:
        return [U[0]]
    if n_max == 1:
        return U[:2]
    for n in range(2, n_max+1):
        Un = sp.simplify(2*x*U[-1] - U[-2])
        U.append(sp.simplify(sp.expand(Un)))
    return U

U = chebyshev_second(9)  # U_0 ... U_9

print("Chebyshev U_n (segunda especie), n=0..9:\n")
for i, p in enumerate(U):
    print(f"U_{i}(x) = {p}")

# Verificación rápida de ortogonalidad (símbolica)
print("\nVerificación de ortogonalidad (integrales):")
for i in range(6):   # muestro sólo algunas para no alargar
    for j in range(i, i+2):
        val = sp.simplify(sp.integrate(U[i]*U[j]*weight, (x, -1, 1)))
        print(f"∫ U_{i} U_{j} sqrt(1-x^2) dx = {val}")
    print("---")

"""3. (d)"""

# -*- coding: utf-8 -*-
"""
Comparación de expansiones de h(x)=sin(3x)*(1-x^2)
- Monomios (proyección L2 peso=1)
- Polinomios de Legendre (peso=1)
- Chebyshev segunda especie U_n (peso = sqrt(1-x^2))
Genera gráficos y errores.
"""

import numpy as np
import scipy.integrate as integrate
import sympy as sp
import matplotlib.pyplot as plt

# ---------- Parámetros ----------
x = sp.Symbol('x')
h_sym = sp.sin(3*x)*(1 - x**2)
h_np = sp.lambdify(x, h_sym, 'numpy')

Nmax = 12             # grado máximo a probar (puedes aumentar)
deg_examples = [2,4,6,8,10,12]  # grados a mostrar en gráficos
EPS_COMPARE = 1e-6    # umbral para "difieren significativamente"

# ---------- Generar polinomios por recurrencia ----------

def legendre_polys(n_max):
    P = [sp.simplify(1), sp.simplify(x)]
    if n_max == 0:
        return [P[0]]
    if n_max == 1:
        return P[:2]
    for n in range(1, n_max):
        # (n+1) P_{n+1} = (2n+1) x P_n - n P_{n-1}
        Pn1 = sp.simplify(((2*n+1)*x*P[n] - n*P[n-1])/(n+1))
        P.append(sp.expand(Pn1))
    # garantizamos Pn(1)=1 (convención)
    P_norm = [sp.simplify(p / p.subs(x,1)) for p in P]
    return P_norm

def chebyshevU_polys(n_max):
    U = [sp.simplify(1)]
    if n_max == 0:
        return U
    U.append(sp.simplify(2*x))
    for n in range(2, n_max+1):
        Un = sp.simplify(2*x*U[-1] - U[-2])
        U.append(sp.expand(Un))
    return U

# ---------- Crear versiones numéricas ----------
P_syms = legendre_polys(Nmax)
U_syms = chebyshevU_polys(Nmax)

P_num = [sp.lambdify(x, p, 'numpy') for p in P_syms]
U_num = [sp.lambdify(x, u, 'numpy') for u in U_syms]

# ---------- Integradores (peso 1 y peso sqrt(1-x^2)) ----------
# Usaremos quad de scipy; para integrales frecuentes se podría usar Gauss en su lugar.

def integrate_1(func):
    val, _ = integrate.quad(func, -1, 1, epsabs=1e-10, epsrel=1e-10, limit=200)
    return val

def integrate_weight_sqrt(func):
    # ∫_{-1}^{1} f(x) sqrt(1-x^2) dx
    val, _ = integrate.quad(lambda t: func(t)*np.sqrt(max(0.0,1.0-t*t)), -1, 1,
                            epsabs=1e-10, epsrel=1e-10, limit=200)
    return val

# ---------- Proyecciones ----------
# 1) Legendre: coef c_n = (2n+1)/2 ∫_{-1}^1 f(x) P_n(x) dx
def project_legendre(f_np, P_num_list, n_max):
    coeffs = np.zeros(n_max+1)
    for n in range(n_max+1):
        integrand = lambda t: f_np(t) * P_num_list[n](t)
        I = integrate_1(integrand)
        coeffs[n] = (2*n + 1)/2.0 * I
    return coeffs

# 2) Chebyshev U (peso sqrt(1-x^2)): coef d_n = (2/pi) ∫ f(x) U_n(x) sqrt(1-x^2) dx
def project_chebyshevU(f_np, U_num_list, n_max):
    coeffs = np.zeros(n_max+1)
    for n in range(n_max+1):
        integrand = lambda t: f_np(t) * U_num_list[n](t)
        I = integrate_weight_sqrt(integrand)
        coeffs[n] = (2.0/np.pi) * I
    return coeffs

# 3) Monomios: resolver sistema de Gram G c = b, con G_{ij}=∫ x^{i+j} dx, b_i = ∫ f x^i dx
#    (usamos peso=1 o peso=sqrt(1-x^2) según caso)
def project_monomial(f_np, n_max, weight='1'):
    # construir G y b numéricamente
    G = np.zeros((n_max+1, n_max+1))
    b = np.zeros(n_max+1)
    for i in range(n_max+1):
        for j in range(n_max+1):
            integrand = lambda t: (t**(i+j)) * (np.sqrt(max(0.0,1.0-t*t)) if weight=='sqrt' else 1.0)
            G[i,j] = integrate_1(integrand) if weight=='1' else integrate_weight_sqrt(lambda tt: tt**(i+j))
        # b
        integrand_b = lambda t: f_np(t) * (t**i) * (np.sqrt(max(0.0,1.0-t*t)) if weight=='sqrt' else 1.0)
        b[i] = integrate_1(integrand_b) if weight=='1' else integrate_weight_sqrt(lambda tt: f_np(tt)*(tt**i))
    coeffs = np.linalg.solve(G, b)
    return coeffs

# ---------- Construir aproximaciones (funciones) ----------
def poly_from_monomial_coeffs(c):
    # c[0] + c[1] x + ...
    def approx(t):
        t = np.asarray(t)
        res = np.zeros_like(t, dtype=float)
        for i, ci in enumerate(c):
            res += ci * t**i
        return res
    return approx

def approx_from_legendre_coeffs(coeffs, P_num_list):
    def approx(t):
        val = np.zeros_like(np.asarray(t), dtype=float)
        for n, cn in enumerate(coeffs):
            val += cn * P_num_list[n](t)
        return val
    return approx

def approx_from_chebyshevU_coeffs(coeffs, U_num_list):
    def approx(t):
        val = np.zeros_like(np.asarray(t), dtype=float)
        for n, cn in enumerate(coeffs):
            val += cn * U_num_list[n](t)
        return val
    return approx

# ---------- Error L2 (con peso) ----------
def L2_error(f_np, approx_fn, weight='1'):
    if weight == '1':
        integrand = lambda t: (f_np(t) - approx_fn(t))**2
        val = integrate_1(integrand)
    else:
        integrand = lambda t: (f_np(t) - approx_fn(t))**2 * np.sqrt(max(0.0,1.0-t*t))
        val = integrate_weight_sqrt(lambda tt: (f_np(tt) - approx_fn(tt))**2)
    return np.sqrt(val)

# ---------- Main: calcular para grados 0..Nmax ----------
results = {
    'monomial_weight1': [],
    'legendre': [],
    'monomial_weight_sqrt': [],
    'chebyshevU': []
}

for N in range(Nmax+1):
    # monomios (peso 1)
    c_mono = project_monomial(h_np, N, weight='1')
    approx_mono = poly_from_monomial_coeffs(c_mono)
    err_mono = L2_error(h_np, approx_mono, weight='1')

    # legendre
    c_leg = project_legendre(h_np, P_num, N)
    approx_leg = approx_from_legendre_coeffs(c_leg, P_num)
    err_leg = L2_error(h_np, approx_leg, weight='1')

    # monomios con peso sqrt (para comparar con Chebyshev)
    c_mono_s = project_monomial(h_np, N, weight='sqrt')
    approx_mono_s = poly_from_monomial_coeffs(c_mono_s)
    err_mono_s = L2_error(h_np, approx_mono_s, weight='sqrt')

    # chebyshev U
    c_U = project_chebyshevU(h_np, U_num, N)
    approx_U = approx_from_chebyshevU_coeffs(c_U, U_num)
    err_U = L2_error(h_np, approx_U, weight='sqrt')

    results['monomial_weight1'].append((N, c_mono, err_mono))
    results['legendre'].append((N, c_leg, err_leg))
    results['monomial_weight_sqrt'].append((N, c_mono_s, err_mono_s))
    results['chebyshevU'].append((N, c_U, err_U))

    print(f"grado {N}: err_mono(L2)= {err_mono:.3e}, err_leg(L2)= {err_leg:.3e}, "
          f"err_mono_s= {err_mono_s:.3e}, err_U= {err_U:.3e}")

# ---------- Graficar la función y aproximaciones seleccionadas ----------
xx = np.linspace(-1, 1, 600)
fxx = h_np(xx)

plt.figure(figsize=(12, 8))
plt.plot(xx, fxx, 'k', lw=2, label='h(x)')

for N in deg_examples:
    # aprox legendre N
    c_leg = results['legendre'][N][1]
    approx_leg_fn = approx_from_legendre_coeffs(c_leg, P_num)
    plt.plot(xx, approx_leg_fn(xx), '--', label=f'Legendre N={N}')
    # aprox monomial N
    c_m = results['monomial_weight1'][N][1]
    approx_m_fn = poly_from_monomial_coeffs(c_m)
    plt.plot(xx, approx_m_fn(xx), ':', label=f'Monomios N={N}')

plt.title("h(x) y aproximaciones (Legendre y Monomios, peso=1)")
plt.legend()
plt.grid(True)
plt.show()

# ---------- Errores vs grado ----------
Ns = [r[0] for r in results['legendre']]
errs_leg = [r[2] for r in results['legendre']]
errs_mono = [r[2] for r in results['monomial_weight1']]
errs_U = [r[2] for r in results['chebyshevU']]
errs_monosqrt = [r[2] for r in results['monomial_weight_sqrt']]

plt.figure(figsize=(8,5))
plt.semilogy(Ns, errs_leg, 'o-', label='Legendre (peso=1)')
plt.semilogy(Ns, errs_mono, 's-', label='Monomios (peso=1)')
plt.semilogy(Ns, errs_U, 'd-', label='Chebyshev U (peso sqrt)')
plt.semilogy(Ns, errs_monosqrt, 'x-', label='Monomios (peso sqrt)')
plt.xlabel('grado N')
plt.ylabel('Error L2')
plt.grid(True, which='both')
plt.legend()
plt.title('Error L2 de aproximaciones')
plt.show()

# ---------- Comparación directa: ¿a partir de qué grado difieren? ----------
# Comparamos aproximaciones (mismo espacio) en peso=1: monomios vs Legendre
first_diff_degree = None
for N in range(Nmax+1):
    approx_m_fn = poly_from_monomial_coeffs(results['monomial_weight1'][N][1])
    approx_l_fn = approx_from_legendre_coeffs(results['legendre'][N][1], P_num)
    # medimos sup-norma en malla o L2
    sup_diff = np.max(np.abs(approx_m_fn(xx) - approx_l_fn(xx)))
    if sup_diff > EPS_COMPARE and first_diff_degree is None:
        first_diff_degree = N
        break

if first_diff_degree is None:
    print("Monomios y Legendre coinciden numericamente hasta Nmax (bajo el umbral).")
else:
    print(f"Primer grado donde monomios y Legendre difieren (umbral {EPS_COMPARE}): N = {first_diff_degree}")

# Puedes salvar coeficientes y hacer más análisis como comparar coeficientes, ver truncamientos, etc.

