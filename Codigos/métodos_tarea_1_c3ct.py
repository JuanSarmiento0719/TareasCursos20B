# -*- coding: utf-8 -*-
"""Métodos tarea 1 C3Ct.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1GVYc3E0f2geS77yfvFxXr9SoeptWvJFK
"""

import sympy
from sympy import *
from sympy.vector import *

"""# Ejercicio 5 Sección 1.1.6

##  Masas iguales a: 1, 2, 3, 4 en los vértices de un cuadrado de lados a = 2.
"""

masas = [1, 2, 3, 4]
pos_m1 = [0, 0]
pos_m2 = [2, 0]
pos_m3 = [0, 2]
pos_m4 = [2, 2]

# posición [x, y]
masa_total = sum(masas)

# producto entre la masa y su posición correspondiente
m1r1 = [masas[0] * i for i in pos_m1]
m2r2 = [masas[1] * i for i in pos_m2]
m3r3 = [masas[2] * i for i in pos_m3]
m4r4 = [masas[3] * i for i in pos_m4]

suma_miri = [a+b+c+d for a, b, c, d in zip(m1r1, m2r2, m3r3, m4r4)]
centro_masa = [1/masa_total * i for i in suma_miri]
centro_masa

"""# Ejercicio 6 Sección 1.2.7"""

R = CoordSys3D('R') # Se define el sistema de coor

# Se definen vectores
a = R.i + 2*R.j + 3*R.k
b = 4*R.i + 5*R.j + 6*R.k
c = 3*R.i + 2*R.j + 1*R.k
d = 6*R.i + 5*R.j + 4*R.k
vectores = [a,b,c,d]
vectores_base = [R.i, R.j, R.k]

# (a) Operaciones aritmeticas con vectores

sumas = a + b + c + d
#display(sumas)

segunda_operación = a + b - c - d
#display(segunda_operación)

tercera_operación = a - b + c - d
#display(tercera_operación)

cuarta_operación = -a + b - c + d
#display(cuarta_operación)


# (b) Calcular el ángulo entre los vectores a, b, c, d y los vectores base.
# El ángulo de dos vectores a y b, se calcula con: theta = arccos(a*b/|a||b|)

rad_i = [acos(x.dot(R.i)/(x.magnitude()*R.i.magnitude())) for x in vectores] # Para i
deg_i = [deg(y).evalf(3) for y in rad_i]
#display(deg_i)

rad_j = [acos(x.dot(R.j)/(x.magnitude()*R.j.magnitude())) for x in vectores] # Para j
deg_j = [deg(y).evalf(3) for y in rad_j]
#display(deg_j)

rad_k = [acos(x.dot(R.k)/(x.magnitude()*R.k.magnitude())) for x in vectores] # Para k
deg_k = [deg(y).evalf(3) for y in rad_k]
#display(deg_k)


# (c) Magnitud de los vectores

# Se puede calcular por la definición de magnitud de un vector
sqrt(a.dot(a)).evalf(3), sqrt(b.dot(b)), sqrt(c.dot(c)), sqrt(d.dot(d))
# o también así
a.magnitude(), b.magnitude(), c.magnitude(), d.magnitude()


# (d) El ángulo entre a y b y entre c y d
ángulo_ab = acos(a.dot(b)/(a.magnitude()*b.magnitude()))
ángulo_cd = acos(c.dot(d)/(c.magnitude()*d.magnitude()))


# (e) Proyección de a sobre b: Proy_ab = (a*b/|b|^2)*b

Proy_ab = (a.dot(b)/b.magnitude()**2)*b
#display(Proy_ab)


# (f) Si los vectores a, b, c, d son coplanares.
# Para hacer esto vamos a formar una matriz con los 4 vectores, luego reducimos la matriz,
# si la matriz reducida es de rango 2 los vectores son coplanares.
# cada columna de la matriz son los vectores, el total de filas final es el rango.
A = Matrix([
  [1,4,3,6],
  [2,5,2,5],
  [3,6,1,4],
])

A_escalonada = A.rref() # .rref() saca la forma escalonada reducida de la matriz
#display(A_escalonada[0]) # aquí vemos que hay solo dos filas no nulas, o sea que el rango es 2
# que el rango sea 2 significa que los vectores son coplanares, ya que entre los 4
# solo se alcanza a generar dos dimensiones (un plano).


# (g) Encontar (a+b)*(c+d)

g = (a+b).dot(c+d)

# (h) Los productos a x b, b x c, c x d y los ángulos que estos forman con d

axb = a.cross(b)
bxc = b.cross(c)
cxd = c.cross(d)

crosses = [axb,bxc,cxd]
con_d = [acos(x.dot(d)/(x.magnitude()*d.magnitude())) for x in crosses]
deg_d = [deg(y) for y in con_d]
#display(deg_d)

# (i) hacer c*(axb)
i = c.dot(axb)

